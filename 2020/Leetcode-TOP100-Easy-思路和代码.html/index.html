<!DOCTYPE html>
<meta name="referrer" content="no-referrer" />


  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Sans TC:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OJ,C++,leetcode," />





  <link rel="alternate" href="/atom.xml" title="Borderland" type="application/atom+xml" />






<meta name="description" content="前言这两天把Leetcode的 Top-100-liked-questions - easy题目做了。 下面就记一下思路和代码，当作记录。 可能因为刚上手吧，感觉也不简单。 当然先记一下探索出来的刷Leetcode的姿势。 后面的话，  先把srp的报告写了， 还有一边学习强国。 天池那个baseline研究一下。 保研的信息继续收集和了解。！！！ 实验室要补实验。  这样的话，这个星期暂且做不了">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-TOP100-Easy:思路和代码">
<meta property="og:url" content="http://jaxchan.top/2020/Leetcode-TOP100-Easy-%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BB%A3%E7%A0%81.html/index.html">
<meta property="og:site_name" content="Borderland">
<meta property="og:description" content="前言这两天把Leetcode的 Top-100-liked-questions - easy题目做了。 下面就记一下思路和代码，当作记录。 可能因为刚上手吧，感觉也不简单。 当然先记一下探索出来的刷Leetcode的姿势。 后面的话，  先把srp的报告写了， 还有一边学习强国。 天池那个baseline研究一下。 保研的信息继续收集和了解。！！！ 实验室要补实验。  这样的话，这个星期暂且做不了">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/15914329-820cdf925a70036b.png">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/15914329-c1d33ecf737cd7c8.png">
<meta property="article:published_time" content="2020-03-31T14:19:22.000Z">
<meta property="article:modified_time" content="2020-03-31T14:21:23.907Z">
<meta property="article:author" content="JaxChan">
<meta property="article:tag" content="OJ">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/15914329-820cdf925a70036b.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jaxchan.top/2020/Leetcode-TOP100-Easy-思路和代码.html/"/>





  <title>Leetcode-TOP100-Easy:思路和代码 | Borderland</title>
  








<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Borderland</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小亮的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jaxchan.top/2020/Leetcode-TOP100-Easy-%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BB%A3%E7%A0%81.html/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JaxChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Borderland">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode-TOP100-Easy:思路和代码</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-31T22:19:22+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/%E4%BF%9D%E7%A0%94/" itemprop="url" rel="index">
                    <span itemprop="name">保研</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天把Leetcode的 <a href="https://leetcode.com/problemset/top-100-liked-questions/?difficulty=Easy" target="_blank" rel="noopener">Top-100-liked-questions - easy</a>题目做了。</p>
<p>下面就记一下思路和代码，当作记录。</p>
<p>可能因为刚上手吧，感觉也不简单。</p>
<p>当然先记一下探索出来的刷Leetcode的姿势。</p>
<p>后面的话，</p>
<ul>
<li>先把srp的报告写了，</li>
<li>还有一边学习强国。</li>
<li>天池那个baseline研究一下。</li>
<li>保研的信息继续收集和了解。！！！</li>
<li>实验室要补实验。</li>
</ul>
<p>这样的话，这个星期暂且做不了多少题。先把上面的事做了吧！</p>
<p>Have a good WEEK!</p>
<p>贴一下列表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"><strong>Title</strong></th>
<th style="text-align:left"><strong>Solution</strong></th>
<th style="text-align:left"><strong>Acceptance</strong></th>
<th style="text-align:left"><strong>Difficulty</strong></th>
<th style="text-align:left"><strong>Frequency</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener">Two Sum</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">45.2%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="noopener">Valid Parentheses</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">38.2%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">21</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/merge-two-sorted-lists" target="_blank" rel="noopener">Merge Two Sorted Lists</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">51.7%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">53</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/maximum-subarray" target="_blank" rel="noopener">Maximum Subarray</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">45.9%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">70</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/climbing-stairs" target="_blank" rel="noopener">Climbing Stairs</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">46.3%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">101</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/symmetric-tree" target="_blank" rel="noopener">Symmetric Tree</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">45.8%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">104</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">64.4%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">121</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">49.6%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">136</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/single-number" target="_blank" rel="noopener">Single Number</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">63.3%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">141</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/linked-list-cycle" target="_blank" rel="noopener">Linked List Cycle</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">39.9%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">155</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/min-stack" target="_blank" rel="noopener">Min Stack</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">41.4%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">160</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/intersection-of-two-linked-lists" target="_blank" rel="noopener">Intersection of Two Linked Lists</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">38.4%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">169</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/majority-element" target="_blank" rel="noopener">Majority Element</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">56.2%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">198</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/house-robber" target="_blank" rel="noopener">House Robber</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">41.6%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">206</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/reverse-linked-list" target="_blank" rel="noopener">Reverse Linked List</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">60.2%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">226</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/invert-binary-tree" target="_blank" rel="noopener">Invert Binary Tree</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">62.1%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">234</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/palindrome-linked-list" target="_blank" rel="noopener">Palindrome Linked List</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">38.2%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">283</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/move-zeroes" target="_blank" rel="noopener">Move Zeroes</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">56.5%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">437</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/path-sum-iii" target="_blank" rel="noopener">Path Sum III</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">45.1%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">448</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array" target="_blank" rel="noopener">Find All Numbers Disappeared in an Array</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">55.3%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">543</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/diameter-of-binary-tree" target="_blank" rel="noopener">Diameter of Binary Tree</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">48.3%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">581</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray" target="_blank" rel="noopener">Shortest Unsorted Continuous Subarray</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">30.7%</td>
<td style="text-align:left"><strong>Easy</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">617</td>
<td style="text-align:left"><a href="https://leetcode.com/problems/merge-two-binary-trees" target="_blank" rel="noopener">Merge Two Binary Trees</a></td>
<td style="text-align:left"></td>
<td style="text-align:left">73.0%</td>
<td style="text-align:left"><strong>Easy</strong></td>
</tr>
</tbody>
</table>
</div>
<h1 id="刷Leetcode的姿势"><a href="#刷Leetcode的姿势" class="headerlink" title="刷Leetcode的姿势"></a>刷Leetcode的姿势</h1><p>正常来说，是直接在Leetcode网页直接写代码。</p>
<p>虽然说有playground可以调试，但是还是本地调试比较舒服。</p>
<p>只需要把playground的代码放在vs就好了，再重定义一下输入 <code>&lt;input.txt</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/15914329-820cdf925a70036b.png" alt="image-20200331191122908"></p>
<p>也要关掉SDL安全检查，不然得用scanf_s换scanf。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/15914329-c1d33ecf737cd7c8.png" alt="image-20200331191146563"></p>
<p>但是要附上以下的头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>定义字典，key为num，value为index.</p>
<p>遍历添加num，但是每次添加都检查一下target - num是否存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;M;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( M.<span class="built_in">find</span>(target-nums[i])!=M.<span class="built_in">end</span>() )&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123; M[target-nums[i]],i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            M[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true</p>
<p>定义一个stack，如果遇到( { [ 就直接压栈，遇到右边的就看看栈顶有没有相应的匹配元素，没有就报错。</p>
<p>最后栈不为空也报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">				<span class="keyword">if</span> (S.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span> (S.top() == <span class="string">'('</span>) &#123;</span><br><span class="line">					S.pop();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">				<span class="keyword">if</span> (S.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span> (S.top() == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">					S.pop();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">				<span class="keyword">if</span> (S.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span> (S.top() == <span class="string">'['</span>) &#123;</span><br><span class="line">					S.pop();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				S.push(s[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!S.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h1><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<p>递归。</p>
<ul>
<li>如果l1到尾了，就返回剩下的l2。</li>
<li>如果l2到尾了，就返回剩下的l1。</li>
<li>如果都没有到尾，小的list的next指向大的list。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt; next = mergeTwoLists(l1-&gt;next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt; next = mergeTwoLists(l1,l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<p>动态规划。</p>
<p>对于第i个值而言，要么是接上上一个连续子数组，要么不接，比较一下两种方式的值，取大的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先放第一个</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                dp.push_back(nums[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">max</span> = nums[i];</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">max</span> +dp[i<span class="number">-1</span>] &gt;<span class="built_in">max</span> )</span><br><span class="line">                <span class="built_in">max</span>=<span class="built_in">max</span> +dp[i<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            dp.push_back(<span class="built_in">max</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p>入门题了。</p>
<p>动态规划。对于第k个台阶而言，达到本台阶只有两种来源：一是来自k-1级，一是来自k-2级。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span> || n==<span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">1001</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">            dp[i] = dp[i<span class="number">-2</span>]+ dp[i<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h1><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre><p>说明:</p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<p>递归。不简单。</p>
<p>首先一棵树是对称的话，镜面位置的NULL和非NULL都是一样的。</p>
<p>所以</p>
<ul>
<li>如果都为NULL，就返回true</li>
<li><p>如果只有一个为NULL，另一个不为NULL，就返回false</p>
</li>
<li><p>最终的表达式：当前值相等 且 左子树的值相等 且 有右子树的值相等</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricHelp(root-&gt;left,root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetricHelp</span><span class="params">(TreeNode* l,TreeNode* r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (!l &amp;&amp; !r)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( !l || !r ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ( l-&gt;val == r-&gt;val) &amp;&amp; (  isSymmetricHelp(l-&gt;left,r-&gt;right)  ) &amp;&amp; ( isSymmetricHelp(l-&gt;right,r-&gt;left) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>​    </p>
<p>老题了。</p>
<p>递归。每次往上返回的值 = max（左子树返回值，右子树返回值） + 1 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>  <span class="built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>简单的动态规划。</p>
<p>每次记录累计的股票价格的最低值。然后计算在这个最低值情况下，当天卖出的利润，如果利润比之前的利润有上升，就sold。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1</p>
<p>异或求不同。</p>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h1><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>虽然入门书可以用拓扑排序判断是否有环。</p>
<p>这里，用快慢指针判断是否有环更方便。</p>
<ul>
<li>如果无环，快指针很快就可以到终点。</li>
<li>如果有环，肯定会有快指针 = 慢指针的时候。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h1><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) — 将元素 x 推入栈中。<br>pop() — 删除栈顶的元素。<br>top() — 获取栈顶元素。<br>getMin() — 检索栈中的最小元素。<br>示例:</p>
<p>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   —&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      —&gt; 返回 0.<br>minStack.getMin();   —&gt; 返回 -2.</p>
<p>定义两个栈就好了。</p>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h1><p>编写一个程序，找到两个单链表AB相交的起始节点。</p>
<p>快慢指针，每个指针循环指向，也就是快指针都对A循环结束后，紧接着对B开始循环，如此往复。而慢指针从B开始。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回相交的节点</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur_a = headA;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur_a)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* cur_b = headB;</span><br><span class="line">            <span class="keyword">while</span> (cur_b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur_a == cur_b)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur_a;</span><br><span class="line">                &#125;</span><br><span class="line">                cur_b = cur_b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h1><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3</p>
<p>示例 2:</p>
<p>输入: [2,2,1,1,1,2,2]<br>输出: 2</p>
<p>hash。定义个字典，key存num，value存出现的次数。如果出现的次数大于n/2，就返回该key。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)   </span><br><span class="line">            <span class="keyword">if</span>(++ hash[n] &gt; nums.<span class="built_in">size</span>()/<span class="number">2</span>)   <span class="keyword">return</span> n;         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>简单的动态规划。</p>
<ul>
<li>如果选择偷k号房，那么就不能偷k-1号房。就等于k-2及以前的最大值 + 本次偷的价值。</li>
<li>如果不偷，就是k-1及以前的价值。</li>
</ul>
<p>每次保存当前最优值就好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        dp.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        dp.push_back(<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp.push_back(   <span class="built_in">max</span>( dp[i<span class="number">-2</span>] + nums[i],dp[i<span class="number">-1</span>] ) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h1><p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>经典题目了。</p>
<p>迭代。定义两个指针，cur指向当前的值（初始化为NULL），pre（我给它一个命名，叫<strong>冲锋指针</strong>）指向下一个值。不断反向就好了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = <span class="literal">NULL</span>, *pre = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="literal">NULL</span>)&#123;</span><br><span class="line"></span><br><span class="line">            ListNode* t = pre-&gt;next;</span><br><span class="line"></span><br><span class="line">            pre-&gt;next = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">            pre = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></h1><p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<pre><code>      4
    /   \
  2     7
 / \   / \
1   3 6   9
</code></pre><p>输出：</p>
<pre><code>      4
    /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><p>树的题目基本都是递归完成的了。</p>
<p>递归的思想其实就是把零散的步骤看成一个整体步骤。</p>
<p>对于一棵树来说，只需要交换root的左子树和右子树。（对于子树来说也是这样）</p>
<p>所以算法步骤也很简单</p>
<ul>
<li>如果树为NULL，则返回NULL。不需要操作它的子树了。</li>
<li>取左子树。</li>
<li>取右子树，</li>
<li>交换。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h1><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>最粗暴的想法就是存在数组里面，再遍历看看是不是。</p>
<p>但是如果要满足O(1)复杂度，需要</p>
<ul>
<li>用快慢指针，快指针走两步，慢指针走一步，找到链表的中点。</li>
<li>翻转链表后半段。</li>
<li>通过两个指针来判断是否是回文链表。</li>
</ul>
<p>我觉得没有太大的意义。就不贴代码了。</p>
<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<p>我的第一思路是冒泡排序的思路，O(n2)。</p>
<p>也可以遇到0就删掉，最后补充。</p>
<p>但作为算法，</p>
<ul>
<li>定义一个count计算非零量。</li>
<li>nums[count++] = nums[i]（当前值），就是往前赋值。</li>
<li>最后末尾赋值为0</li>
</ul>
<h1 id="路径总和-III-有点难"><a href="#路径总和-III-有点难" class="headerlink" title="路径总和 III - 有点难"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a> - 有点难</h1><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], sum &#x3D; 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    5   -3</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">返回 3。和等于 8 的路径有:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure>
<p>这个还是没想明白。先留坑。</p>
<h1 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></h1><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<p>输入:<br>[4,3,2,7,8,2,3,1]</p>
<p>输出:<br>[5,6]</p>
<p>对出现的值，对其值表示的index上的值加一个offset代表这个值出现过。</p>
<p>再一个遍历看看哪个值没有超过这个offset，就知道缺谁了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index=(nums[i]<span class="number">-1</span>)%nums.<span class="built_in">size</span>();</span><br><span class="line">            nums[index]+=nums.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=nums.<span class="built_in">size</span>())</span><br><span class="line">                res.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></h1><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>示例 :<br>给定二叉树返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure>
<p>经典树的遍历了。</p>
<ul>
<li><p>正常计算深度。max( 左子树深度，右子树深度) +1</p>
</li>
<li><p>定义一个类变量maxD，计算所有遍历里面最大的直径，即 maxD = max(maxD, 左子树深度 + 右子树深度  )</p>
</li>
</ul>
<p>我用了一个更复杂的传多个值的方式实现，传深度和子节点最大的直径，贴一下吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> a = helper(root-&gt;left);</span><br><span class="line">            <span class="keyword">auto</span> b = helper(root-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> diameter = <span class="built_in">max</span>(<span class="built_in">max</span>( a[<span class="number">1</span>],b[<span class="number">1</span>]),a[<span class="number">0</span>] + b[<span class="number">0</span>]  );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> diameter;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">helper</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root ==<span class="literal">NULL</span>)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> a = helper(root-&gt;left);</span><br><span class="line">            <span class="keyword">auto</span> b = helper(root-&gt;right);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> depth = <span class="built_in">max</span>(a[<span class="number">0</span>],b[<span class="number">0</span>]) + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">int</span> diameter = <span class="built_in">max</span>(<span class="built_in">max</span>( a[<span class="number">1</span>],b[<span class="number">1</span>]),a[<span class="number">0</span>] + b[<span class="number">0</span>]  );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;depth,diameter&#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">581. 最短无序连续子数组</a></h1><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是最短的，请输出它的长度。</p>
<p>示例 1:</p>
<p>输入: [2, 6, 4, 8, 10, 9, 15]<br>输出: 5<br>解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>说明 :</p>
<p>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</p>
<p>先排序是最快的做法。</p>
<p>但如果最好不排序，那寻找左右两边的privot值。</p>
<p>要保证整个数组是升序的，就不能出现峰值。</p>
<ul>
<li>左privot：最早出现的（从左到右）同时大于两边值的index</li>
<li>右privot：最早出现的（从右到左）同时小于两边值的index</li>
</ul>
<p>统计两个privot之间有多少个元素就可以了。</p>
<h1 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p>遇到树一般都是递归。</p>
<ul>
<li><p>如果t1或t2为空，就返回NULL。</p>
</li>
<li><p>如果都不为空，就将t2的值加到了t1</p>
</li>
<li>如果t1左节点为空，就t1-&gt;left指向t2-&gt;left。</li>
<li>如果t1右节点为空，就t1-&gt;right指向t2-&gt;right。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">NULL</span>)  <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t2==<span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> help(t1,t2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        <span class="comment">//存在为空</span></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">NULL</span> || t2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//都不为空</span></span><br><span class="line">        <span class="keyword">if</span>( t1 != <span class="literal">NULL</span> &amp;&amp; t2 !=<span class="literal">NULL</span> )</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( help(t1-&gt;left,t2-&gt;left) ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( t1-&gt;left == <span class="literal">NULL</span> )</span><br><span class="line">                t1-&gt;left = t2-&gt;left;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( help(t1-&gt;right,t2-&gt;right) ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( t1-&gt;right == <span class="literal">NULL</span> )</span><br><span class="line">                t1-&gt;right = t2-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到解答里面有更清晰的思路，有那个合并多个链表的感觉。</p>
<p>值得学习一下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> &amp;&amp; t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">            t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">            t1-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OJ/" rel="tag"># OJ</a>
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/Oj%E4%B8%8A%E6%89%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E9%A2%98%E5%9E%8B%E5%92%8C%E6%80%9D%E8%B7%AF.html/" rel="next" title="Oj上手：基本题型和思路">
                <i class="fa fa-chevron-left"></i> Oj上手：基本题型和思路
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86-%E5%90%8E%E7%AB%AF%E4%B8%9A%E5%8A%A1%E6%A1%86%E6%9E%B6%E8%AE%B0%E5%BD%95.html/" rel="prev" title="我的项目经历:后端业务框架记录">
                我的项目经历:后端业务框架记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="JaxChan" />
            
              <p class="site-author-name" itemprop="name">JaxChan</p>
              <p class="site-description motion-element" itemprop="description">你来了 我也不知道说些什么</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jaxchan25" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://upload-images.jianshu.io/upload_images/15914329-cb64457e2b808dff.jpg" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-envelope"></i>Wechat</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#刷Leetcode的姿势"><span class="nav-number">2.</span> <span class="nav-text">刷Leetcode的姿势</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-两数之和"><span class="nav-number">3.</span> <span class="nav-text">1. 两数之和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-有效的括号"><span class="nav-number">4.</span> <span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-合并两个有序链表"><span class="nav-number">5.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-最大子序和"><span class="nav-number">6.</span> <span class="nav-text">53. 最大子序和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-爬楼梯"><span class="nav-number">7.</span> <span class="nav-text">70. 爬楼梯</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-对称二叉树"><span class="nav-number">8.</span> <span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-二叉树的最大深度"><span class="nav-number">9.</span> <span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-买卖股票的最佳时机"><span class="nav-number">10.</span> <span class="nav-text">121. 买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-只出现一次的数字"><span class="nav-number">11.</span> <span class="nav-text">136. 只出现一次的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-环形链表"><span class="nav-number">12.</span> <span class="nav-text">141. 环形链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-最小栈"><span class="nav-number">13.</span> <span class="nav-text">155. 最小栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-相交链表"><span class="nav-number">14.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-多数元素"><span class="nav-number">15.</span> <span class="nav-text">169. 多数元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-打家劫舍"><span class="nav-number">16.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-反转链表"><span class="nav-number">17.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#226-翻转二叉树"><span class="nav-number">18.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-回文链表"><span class="nav-number">19.</span> <span class="nav-text">234. 回文链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#283-移动零"><span class="nav-number">20.</span> <span class="nav-text">283. 移动零</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路径总和-III-有点难"><span class="nav-number">21.</span> <span class="nav-text">路径总和 III - 有点难</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#448-找到所有数组中消失的数字"><span class="nav-number">22.</span> <span class="nav-text">448. 找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#543-二叉树的直径"><span class="nav-number">23.</span> <span class="nav-text">543. 二叉树的直径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#581-最短无序连续子数组"><span class="nav-number">24.</span> <span class="nav-text">581. 最短无序连续子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#617-合并二叉树"><span class="nav-number">25.</span> <span class="nav-text">617. 合并二叉树</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JaxChan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>





        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
